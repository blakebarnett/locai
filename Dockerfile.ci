# Multi-stage Dockerfile for CI builds
# Simplified version without sccache - relies on BuildKit layer caching
#
# Build with: DOCKER_BUILDKIT=1 docker build -f Dockerfile.ci -t locai-server:latest .
#
# Note: Uses Rust nightly because Locai requires edition 2024

# BuildKit automatically provides TARGETARCH, but we need to declare it as ARG to use it
ARG TARGETARCH
ARG TARGETPLATFORM

# ============================================================================
# Stage 1: Build dependencies and cache them
# ============================================================================
FROM rustlang/rust:nightly-bookworm AS chef

# Install cargo-chef for dependency caching
RUN cargo install cargo-chef --locked

WORKDIR /app

# ============================================================================
# Stage 2: Prepare the dependency recipe
# ============================================================================
FROM chef AS planner

# Copy only the packages needed for locai-server (locai core + locai-server)
# This reduces the build context and avoids building unnecessary dependencies
COPY Cargo.toml ./
COPY Cargo.lock* ./
COPY locai ./locai
COPY locai-server ./locai-server

# Verify versions are correct (helps catch cache issues)
RUN echo "Verifying package versions:" && \
    grep -E '^version\s*=' Cargo.toml locai/Cargo.toml locai-server/Cargo.toml || true

# Modify Cargo.toml to only include the members we need (locai + locai-server)
# This prevents cargo from looking for locai-cli which we don't copy
RUN sed -i '/locai-cli/d' Cargo.toml

# CRITICAL: Regenerate Cargo.lock BEFORE preparing recipe
# cargo-chef uses Cargo.lock to determine what to include, so it must be up-to-date
# This ensures versions are correct in the recipe.json
RUN cargo generate-lockfile || echo "Warning: Failed to generate Cargo.lock"

# Verify workspace resolution and show actual versions being used
RUN echo "=== Workspace Resolution Check (Planner Stage) ===" && \
    cargo metadata --format-version 1 > /tmp/metadata.json 2>&1 && \
    echo "Package versions from metadata:" && \
    (cat /tmp/metadata.json | jq -r '.packages[] | select(.name | startswith("locai")) | "\(.name): \(.version)"' 2>/dev/null || \
     cat /tmp/metadata.json | grep -A 2 '"name":"locai' | grep -E '"name"|"version"') || \
    (echo "Failed to get metadata, regenerating lockfile..." && cargo generate-lockfile)

# Analyze dependencies (will only include locai and locai-server since that's all we copied)
# This recipe will be used by the dependencies stage, so versions must be correct here
RUN cargo chef prepare --recipe-path recipe.json

# ============================================================================
# Stage 3: Build dependencies (cached layer)
# ============================================================================
FROM chef AS dependencies

# Redeclare ARG for this stage
ARG TARGETARCH

# Install build dependencies for native libraries (RocksDB, etc.)
RUN apt-get update && apt-get install -y \
    build-essential \
    libclang-dev \
    clang \
    cmake \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy the dependency recipe
COPY --from=planner /app/recipe.json recipe.json

# Build dependencies (only for packages in the recipe: locai + locai-server)
# Use CI profile for faster builds, cache target directory for incremental builds
# Mount rust-cache from GitHub Actions runner if available (for shared cache across CI runs)
# Copy compiled dependencies out of cache mount to make them available for next stage
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/usr/local/cargo/git \
    --mount=type=cache,target=/app/target \
    --mount=type=bind,source=.rust-cache-cargo,target=/tmp/rust-cache-cargo,readonly \
    --mount=type=bind,source=.rust-cache-target,target=/tmp/rust-cache-target,readonly \
    bash -c '\
    if [ -d /tmp/rust-cache-cargo ] && [ "$(ls -A /tmp/rust-cache-cargo 2>/dev/null | grep -v .keep)" ]; then \
      echo "Using rust-cache cargo registry/git from GitHub Actions (architecture-independent)..." && \
      # Only copy registry and git (architecture-independent), skip bin (architecture-specific) \
      if [ -d /tmp/rust-cache-cargo/registry ]; then \
        cp -r /tmp/rust-cache-cargo/registry /usr/local/cargo/ 2>/dev/null || true; \
      fi && \
      if [ -d /tmp/rust-cache-cargo/git ]; then \
        cp -r /tmp/rust-cache-cargo/git /usr/local/cargo/ 2>/dev/null || true; \
      fi; \
    fi && \
    # Skip target cache for cross-architecture builds (target contains compiled artifacts) \
    # Only use target cache if building for same architecture as runner (amd64) \
    # Detect architecture: if we're in qemu emulator, we're cross-compiling \
    if [ ! -f /dev/.buildkit_qemu_emulator ] && [ -d /tmp/rust-cache-target ] && [ "$(ls -A /tmp/rust-cache-target 2>/dev/null | grep -v .keep)" ]; then \
      echo "Using rust-cache target from GitHub Actions (native amd64 build)..." && \
      cp -r /tmp/rust-cache-target/* /app/target/ 2>/dev/null || true; \
    elif [ -f /dev/.buildkit_qemu_emulator ]; then \
      echo "Skipping rust-cache target (cross-architecture build detected)"; \
    fi && \
    cargo chef cook --profile ci --recipe-path recipe.json && \
    mkdir -p /app/deps-target && \
    if [ -d /app/target ] && [ "$(ls -A /app/target 2>/dev/null)" ]; then \
      cp -r /app/target/* /app/deps-target/ 2>/dev/null || true; \
    fi && \
    touch /app/deps-target/.keep || true'

# Ensure deps-target directory exists even if empty (required for COPY in next stage)
RUN mkdir -p /app/deps-target && touch /app/deps-target/.keep

# ============================================================================
# Stage 4: Build the application
# ============================================================================
FROM chef AS builder

# Redeclare ARG for this stage
ARG TARGETARCH

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    libclang-dev \
    clang \
    cmake \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy cargo registry and compiled dependencies from previous stage
COPY --from=dependencies /usr/local/cargo /usr/local/cargo
# Copy dependencies target (may be empty on first build, but directory always exists)
COPY --from=dependencies /app/deps-target /app/target

# Copy only the source code needed for locai-server
# Note: We don't copy .cargo/config.toml since it references sccache which we don't use in CI
COPY Cargo.toml ./
COPY Cargo.lock* ./
COPY locai ./locai
COPY locai-server ./locai-server

# Verify versions are correct before building (helps catch cache issues)
RUN echo "Verifying package versions in builder stage:" && \
    grep -E '^version\s*=' Cargo.toml locai/Cargo.toml locai-server/Cargo.toml || true

# Modify Cargo.toml to only include the members we need (locai + locai-server)
# This prevents cargo from looking for locai-cli which we don't copy
RUN sed -i '/locai-cli/d' Cargo.toml

# Regenerate Cargo.lock after modifying workspace to ensure correct resolution
# This is critical - Cargo.lock may have references to locai-cli that need to be removed
RUN cargo generate-lockfile || echo "Warning: Failed to generate Cargo.lock"

# Verify workspace resolution and show actual versions being used
RUN echo "=== Workspace Resolution Check (Builder Stage) ===" && \
    cargo metadata --format-version 1 > /tmp/metadata.json 2>&1 && \
    echo "Package versions from metadata:" && \
    cat /tmp/metadata.json | grep -A 2 '"name":"locai' | grep -E '"name"|"version"' || \
    (echo "Failed to get metadata, regenerating lockfile..." && cargo generate-lockfile)

# Build only the locai-server binary (BuildKit will cache this layer)
# Use CI profile for faster builds, cache target directory for incremental builds
# Mount rust-cache from GitHub Actions runner if available (for shared cache across CI runs)
# Copy binary out of cache mount to make it available in the image layer
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/usr/local/cargo/git \
    --mount=type=cache,target=/app/target \
    --mount=type=bind,source=.rust-cache-cargo,target=/tmp/rust-cache-cargo,readonly \
    --mount=type=bind,source=.rust-cache-target,target=/tmp/rust-cache-target,readonly \
    bash -c '\
    set -e && \
    if [ -d /tmp/rust-cache-cargo ] && [ "$(ls -A /tmp/rust-cache-cargo 2>/dev/null | grep -v .keep)" ]; then \
      echo "Using rust-cache cargo registry/git from GitHub Actions (architecture-independent)..." && \
      # Only copy registry and git (architecture-independent), skip bin (architecture-specific) \
      if [ -d /tmp/rust-cache-cargo/registry ]; then \
        cp -r /tmp/rust-cache-cargo/registry /usr/local/cargo/ 2>/dev/null || true; \
      fi && \
      if [ -d /tmp/rust-cache-cargo/git ]; then \
        cp -r /tmp/rust-cache-cargo/git /usr/local/cargo/ 2>/dev/null || true; \
      fi; \
    fi && \
    # Skip target cache for cross-architecture builds (target contains compiled artifacts) \
    # Only use target cache if building for same architecture as runner (amd64) \
    # Detect architecture: if we're in qemu emulator, we're cross-compiling \
    if [ ! -f /dev/.buildkit_qemu_emulator ] && [ -d /tmp/rust-cache-target ] && [ "$(ls -A /tmp/rust-cache-target 2>/dev/null | grep -v .keep)" ]; then \
      echo "Using rust-cache target from GitHub Actions (native amd64 build)..." && \
      cp -r /tmp/rust-cache-target/* /app/target/ 2>/dev/null || true; \
    elif [ -f /dev/.buildkit_qemu_emulator ]; then \
      echo "Skipping rust-cache target (cross-architecture build detected)"; \
    fi && \
    cargo build --profile ci --bin locai-server && \
    mkdir -p /app/bin && \
    cp /app/target/ci/locai-server /app/bin/locai-server'

# Verify the binary exists and is executable
RUN ls -lh /app/bin/locai-server && \
    file /app/bin/locai-server && \
    /app/bin/locai-server --help

# ============================================================================
# Stage 5: Runtime image (final, minimal)
# ============================================================================
FROM debian:bookworm-slim AS runtime

# Install runtime dependencies
# - ca-certificates: for HTTPS/TLS
# - libssl3: OpenSSL runtime
# - bash: useful shell for debugging
RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    bash \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Create a non-root user for security
RUN groupadd -r locai && useradd -r -g locai -u 1000 locai

# Create data directory with proper permissions
RUN mkdir -p /data && chown -R locai:locai /data

# Copy the compiled binary from builder (copied out of cache mount to /app/bin/)
COPY --from=builder /app/bin/locai-server /usr/local/bin/locai-server

# Verify binary is executable
RUN chmod +x /usr/local/bin/locai-server

# Switch to non-root user
USER locai

# Set working directory
WORKDIR /data

# Expose default port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/api/health || exit 1

# Default command
CMD ["locai-server"]

# ============================================================================
# Metadata
# ============================================================================
LABEL org.opencontainers.image.title="Locai Server"
LABEL org.opencontainers.image.description="Memory management service with graph-centric design"
LABEL org.opencontainers.image.version="0.2.0"
LABEL org.opencontainers.image.source="https://github.com/blakebarnett/locai"
LABEL org.opencontainers.image.licenses="MIT"
LABEL org.opencontainers.image.documentation="See DOCKER_BUILD_GUIDE.md"

